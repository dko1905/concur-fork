todo:
=====
progress bar which tracks --timeout?  --pbar {jobs|time} maybe?

document new features since last release

per-job vs overall timeout 
  per-job: if a job takes too long, kill it but keep processing
  overall: when we hit this absolute limit, kill everything
  

package things: nix, aqua, brew, mise.

clean up code, make it testable

TEST.


ok, multicontext design.

AI code


func worker(ctx context.Context, id int, wg *sync.WaitGroup) {
    defer wg.Done()

    done := make(chan bool)

    go func() {
        time.Sleep(7 * time.Second) // Longer than timeout to demonstrate cancellation
        done <- true
    }()

    select {
    case <-done:
        fmt.Printf("Worker %d completed successfully\n", id)
    case <-ctx.Done():
        fmt.Printf("Worker %d cancelled due to timeout\n", id)
    }
}

func main() {
    // Create main context with 10 second timeout
    mainCtx, mainCancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer mainCancel()

    // Main processing loop
    for i := 0; i < 3; i++ {
        fmt.Printf("\nStarting iteration %d\n", i+1)

        var wg sync.WaitGroup

        // Start multiple workers, each with its own context
        for j := 0; j < 3; j++ {
            // Create individual context for each worker
            workerCtx, workerCancel := context.WithTimeout(mainCtx, 5*time.Second)

            // Ensure we clean up each worker's context
            defer workerCancel()

            wg.Add(1)
            go worker(workerCtx, j+1, &wg)
        }

        // Wait for all workers to complete or timeout
        wg.Wait()

        // Check if main context has been cancelled
        select {
        case <-mainCtx.Done():
            fmt.Println("Main context cancelled, exiting loop")
            return
        default:
            // Continue to next iteration
        }
    }
}

for me that's

command_loop as outer
  it's passed a context, ctx. 
  set timeout.
execute_single_command as inner
  it's NOT passed a context but I should create one with         
  
      workerCtx, workerCancel := context.WithTimeout(mainCtx, 5*time.Second)

      // Ensure we clean up each worker's context
      defer workerCancel()

* need to ensure that the worker timeout is <= outer timeout, it can be zero
* need to come up with conforming names
* need CLI arg to set job timeout --job-timeout 

jobCtx and (mainCtx?  outerCtx? commandLoopCtx?  loopCtx for now)


